//! Stream-JSON event types for the Claude CLI `--output-format stream-json`.
//!
//! Each line of output from `claude -p --output-format stream-json --verbose`
//! is a self-contained JSON object. The `type` field discriminates the variant.
//!
//! # Event sequence (typical)
//!
//! ```text
//! system/hook_started  → system/hook_response  (repeated per hook)
//! system/init          → session metadata
//! assistant            → content blocks (text | tool_use), may repeat
//! user                 → tool_result (auto-generated by CLI)
//! ...                  → more assistant/user turns
//! result/success       → final outcome with usage + cost
//! ```

use std::collections::HashMap;

use serde::Deserialize;

/// A single event from the Claude CLI stream-json output.
///
/// Uses `#[serde(tag = "type")]` to dispatch on the `type` field.
/// Unknown event types are captured as `Unknown`.
#[derive(Debug, Clone, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum StreamEvent {
    /// System lifecycle events (init, hooks, errors).
    System(SystemEvent),
    /// Assistant turn — contains content blocks (text, `tool_use`).
    Assistant(AssistantEvent),
    /// User turn — typically auto-generated tool results.
    User(UserEvent),
    /// Final result — session complete.
    Result(ResultEvent),
    /// Stream delta events (with `--include-partial-messages`).
    #[serde(rename = "stream_event")]
    StreamDelta(StreamDeltaEvent),
}

// ─── System events ───────────────────────────────────────────

/// System-level events from the CLI.
#[derive(Debug, Clone, Deserialize)]
pub struct SystemEvent {
    /// The subtype discriminator.
    #[serde(default)]
    pub subtype: String,
    /// Session ID (present on most system events).
    #[serde(default)]
    pub session_id: Option<String>,
    /// UUID for this event.
    #[serde(default)]
    pub uuid: Option<String>,
    /// For `init`: available tools.
    #[serde(default)]
    pub tools: Option<Vec<String>>,
    /// For `init`: connected MCP servers.
    #[serde(default)]
    pub mcp_servers: Option<Vec<McpServerInfo>>,
    /// For `init`: model name.
    #[serde(default)]
    pub model: Option<String>,
    /// For `init`: Claude Code version.
    #[serde(default)]
    pub claude_code_version: Option<String>,
    /// For `init`: working directory.
    #[serde(default)]
    pub cwd: Option<String>,
    /// For hooks: hook name.
    #[serde(default)]
    pub hook_name: Option<String>,
    /// For hooks: hook event type.
    #[serde(default)]
    pub hook_event: Option<String>,
    /// For `init`: installed plugins.
    #[serde(default)]
    pub plugins: Option<Vec<PluginInfo>>,
    /// For `init`: permission mode (e.g. "default", "plan").
    #[serde(default, rename = "permissionMode")]
    pub permission_mode: Option<String>,
}

/// MCP server connection info from the `init` event.
#[derive(Debug, Clone, Deserialize)]
pub struct McpServerInfo {
    /// Server name (e.g. "plugin:serena:serena").
    pub name: String,
    /// Connection status.
    pub status: String,
}

/// Plugin info from the `init` event.
#[derive(Debug, Clone, Deserialize)]
pub struct PluginInfo {
    /// Plugin name (e.g. "exo-self").
    pub name: String,
    /// Path to the plugin.
    #[serde(default)]
    pub path: Option<String>,
}

// ─── Assistant events ────────────────────────────────────────

/// An assistant turn containing one or more content blocks.
#[derive(Debug, Clone, Deserialize)]
pub struct AssistantEvent {
    /// The assistant message.
    pub message: AssistantMessage,
    /// Session ID.
    #[serde(default)]
    pub session_id: Option<String>,
    /// If this is from a subagent, the parent `tool_use` ID.
    #[serde(default)]
    pub parent_tool_use_id: Option<String>,
}

/// The message payload from the assistant.
#[derive(Debug, Clone, Deserialize)]
pub struct AssistantMessage {
    /// Model that generated this message.
    #[serde(default)]
    pub model: Option<String>,
    /// Content blocks.
    #[serde(default)]
    pub content: Vec<ContentBlock>,
    /// Why the model stopped.
    #[serde(default)]
    pub stop_reason: Option<String>,
}

/// A content block within an assistant message.
#[derive(Debug, Clone, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ContentBlock {
    /// Plain text output.
    Text {
        /// The text content.
        text: String,
    },
    /// A tool use request.
    ToolUse {
        /// Unique ID for this tool invocation.
        id: String,
        /// Tool name (e.g. "Read", "Bash", "Edit").
        name: String,
        /// Tool input parameters.
        #[serde(default)]
        input: HashMap<String, serde_json::Value>,
    },
    /// Thinking block (extended thinking).
    Thinking {
        /// The thinking content.
        #[serde(default)]
        thinking: String,
    },
}

// ─── User events ─────────────────────────────────────────────

/// A user turn — typically auto-generated tool results.
#[derive(Debug, Clone, Deserialize)]
pub struct UserEvent {
    /// The user message containing tool results.
    pub message: UserMessage,
    /// Session ID.
    #[serde(default)]
    pub session_id: Option<String>,
}

/// User message payload.
#[derive(Debug, Clone, Deserialize)]
pub struct UserMessage {
    /// Content blocks (tool results).
    #[serde(default)]
    pub content: Vec<UserContentBlock>,
}

/// A content block in a user message.
#[derive(Debug, Clone, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum UserContentBlock {
    /// A tool execution result.
    ToolResult {
        /// The `tool_use` ID this result corresponds to.
        tool_use_id: String,
        /// The result content (can be string or structured).
        #[serde(default)]
        content: serde_json::Value,
        /// Whether the tool execution errored.
        #[serde(default)]
        is_error: bool,
    },
}

// ─── Result events ───────────────────────────────────────────

/// Final result event when the session completes.
#[derive(Debug, Clone, Deserialize)]
pub struct ResultEvent {
    /// Success or error subtype.
    #[serde(default)]
    pub subtype: String,
    /// Whether this was an error.
    #[serde(default)]
    pub is_error: bool,
    /// Duration of the session in milliseconds.
    #[serde(default)]
    pub duration_ms: Option<u64>,
    /// Number of agent turns.
    #[serde(default)]
    pub num_turns: Option<u32>,
    /// The final text result.
    #[serde(default)]
    pub result: Option<String>,
    /// Session ID for continuation.
    #[serde(default)]
    pub session_id: Option<String>,
    /// Total cost in USD.
    #[serde(default)]
    pub total_cost_usd: Option<f64>,
    /// Per-model usage breakdown (token counts, context window size).
    #[serde(default, rename = "modelUsage")]
    pub model_usage: Option<HashMap<String, ModelUsage>>,
}

/// Per-model token usage from a result event.
#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ModelUsage {
    /// Prompt tokens (excluding cache).
    #[serde(default)]
    pub input_tokens: u64,
    /// Completion tokens.
    #[serde(default)]
    pub output_tokens: u64,
    /// Tokens served from cache.
    #[serde(default)]
    pub cache_read_input_tokens: u64,
    /// Tokens written to cache.
    #[serde(default)]
    pub cache_creation_input_tokens: u64,
    /// Model's total context window size.
    #[serde(default)]
    pub context_window: u64,
    /// Cost in USD for this model's usage.
    #[serde(default)]
    pub cost_usd: Option<f64>,
}

// ─── Stream delta events ─────────────────────────────────────

/// Streaming delta event (with `--include-partial-messages`).
#[derive(Debug, Clone, Deserialize)]
pub struct StreamDeltaEvent {
    /// The delta event payload.
    #[serde(default)]
    pub event: Option<serde_json::Value>,
}

// ─── Parsing ─────────────────────────────────────────────────

/// Parse a single line of stream-json into a `StreamEvent`.
///
/// Returns `None` for empty lines or unparseable events.
pub fn parse_event(line: &str) -> Option<StreamEvent> {
    let line = line.trim();
    if line.is_empty() {
        return None;
    }
    serde_json::from_str(line).ok()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_init_event() {
        let line = r#"{"type":"system","subtype":"init","session_id":"abc-123","tools":["Read","Bash"],"model":"claude-opus-4-6","cwd":"/tmp"}"#;
        let event = parse_event(line).expect("should parse");
        match event {
            StreamEvent::System(sys) => {
                assert_eq!(sys.subtype, "init");
                assert_eq!(sys.session_id.as_deref(), Some("abc-123"));
                assert_eq!(sys.model.as_deref(), Some("claude-opus-4-6"));
                assert_eq!(sys.tools.as_ref().map(Vec::len), Some(2));
            }
            _ => panic!("expected System event"),
        }
    }

    #[test]
    fn parse_assistant_text() {
        let line = r#"{"type":"assistant","message":{"content":[{"type":"text","text":"hello gleisner"}],"stop_reason":null},"session_id":"abc"}"#;
        let event = parse_event(line).expect("should parse");
        match event {
            StreamEvent::Assistant(asst) => {
                assert_eq!(asst.message.content.len(), 1);
                match &asst.message.content[0] {
                    ContentBlock::Text { text } => assert_eq!(text, "hello gleisner"),
                    _ => panic!("expected Text block"),
                }
            }
            _ => panic!("expected Assistant event"),
        }
    }

    #[test]
    fn parse_assistant_tool_use() {
        let line = r#"{"type":"assistant","message":{"content":[{"type":"tool_use","id":"toolu_123","name":"Read","input":{"file_path":"/tmp/foo"}}]},"session_id":"abc"}"#;
        let event = parse_event(line).expect("should parse");
        match event {
            StreamEvent::Assistant(asst) => match &asst.message.content[0] {
                ContentBlock::ToolUse { id, name, input } => {
                    assert_eq!(id, "toolu_123");
                    assert_eq!(name, "Read");
                    assert_eq!(
                        input.get("file_path").and_then(|v| v.as_str()),
                        Some("/tmp/foo")
                    );
                }
                _ => panic!("expected ToolUse block"),
            },
            _ => panic!("expected Assistant event"),
        }
    }

    #[test]
    fn parse_result_event() {
        let line = r#"{"type":"result","subtype":"success","is_error":false,"duration_ms":3029,"num_turns":1,"result":"hello","session_id":"abc-123","total_cost_usd":0.286}"#;
        let event = parse_event(line).expect("should parse");
        match event {
            StreamEvent::Result(res) => {
                assert_eq!(res.subtype, "success");
                assert!(!res.is_error);
                assert_eq!(res.session_id.as_deref(), Some("abc-123"));
                assert_eq!(res.result.as_deref(), Some("hello"));
                assert!((res.total_cost_usd.unwrap() - 0.286).abs() < 0.001);
            }
            _ => panic!("expected Result event"),
        }
    }

    #[test]
    fn parse_result_event_with_model_usage() {
        let line = r#"{"type":"result","subtype":"success","is_error":false,"duration_ms":4584,"num_turns":1,"result":"4","session_id":"abc","total_cost_usd":0.060547,"modelUsage":{"claude-opus-4-6":{"inputTokens":3,"outputTokens":5,"cacheReadInputTokens":39214,"cacheCreationInputTokens":6528,"contextWindow":200000,"costUSD":0.060547}}}"#;
        let event = parse_event(line).expect("should parse");
        match event {
            StreamEvent::Result(res) => {
                let usage_map = res.model_usage.expect("should have modelUsage");
                let usage = usage_map.get("claude-opus-4-6").expect("should have opus");
                assert_eq!(usage.input_tokens, 3);
                assert_eq!(usage.output_tokens, 5);
                assert_eq!(usage.cache_read_input_tokens, 39214);
                assert_eq!(usage.cache_creation_input_tokens, 6528);
                assert_eq!(usage.context_window, 200_000);
                let total = usage.input_tokens
                    + usage.output_tokens
                    + usage.cache_read_input_tokens
                    + usage.cache_creation_input_tokens;
                assert_eq!(total, 45750);
                let pct = total as f64 / usage.context_window as f64 * 100.0;
                assert!((pct - 22.875).abs() < 0.01);
            }
            _ => panic!("expected Result event"),
        }
    }

    #[test]
    fn parse_user_tool_result() {
        let line = r#"{"type":"user","message":{"content":[{"type":"tool_result","tool_use_id":"toolu_123","content":"file contents here","is_error":false}]}}"#;
        let event = parse_event(line).expect("should parse");
        match event {
            StreamEvent::User(user) => {
                assert_eq!(user.message.content.len(), 1);
                match &user.message.content[0] {
                    UserContentBlock::ToolResult {
                        tool_use_id,
                        is_error,
                        ..
                    } => {
                        assert_eq!(tool_use_id, "toolu_123");
                        assert!(!is_error);
                    }
                }
            }
            _ => panic!("expected User event"),
        }
    }

    /// Test parsing a real captured event from `claude -p --output-format stream-json`.
    #[test]
    fn parse_real_init_event() {
        let line = r#"{"type":"system","subtype":"init","cwd":"/datar/workspace","session_id":"6a9afc8c-442b-4bc2-b053-d93ec1f99f16","tools":["Read","Bash","Glob"],"mcp_servers":[{"name":"plugin:serena:serena","status":"connected"}],"model":"claude-opus-4-6","claude_code_version":"2.1.42"}"#;
        let event = parse_event(line).expect("should parse real init event");
        match event {
            StreamEvent::System(sys) => {
                assert_eq!(sys.subtype, "init");
                assert_eq!(sys.claude_code_version.as_deref(), Some("2.1.42"));
                let servers = sys.mcp_servers.as_ref().unwrap();
                assert_eq!(servers[0].name, "plugin:serena:serena");
                assert_eq!(servers[0].status, "connected");
            }
            _ => panic!("expected System event"),
        }
    }

    #[test]
    fn empty_and_whitespace_lines_return_none() {
        assert!(parse_event("").is_none());
        assert!(parse_event("   ").is_none());
        assert!(parse_event("\n").is_none());
    }
}
